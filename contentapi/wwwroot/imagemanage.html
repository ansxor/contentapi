<!DOCTYPE html>
<html lang="en">

<head>
    <script src="api.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <script>
const ATTR_MODIFIED = "data-modified";
const ENTERCODE = "Enter";

var api;
var userSelf;
var keywordCache;

//The default values for searching are set here, but the variable is used to indicate
//the CURRENT state of searching (so the values are substituted from the URL)
var SearchState = {
    ipp : 100,
    isize : 300, /* want it at 200, but browser is doing something weird */
    id : 0,
    own : 0,
    oldest: 0
};

//duplicate from index.js
const TOKENKEY = "contentapi_defimpl_userkey";
function GetToken() { return localStorage.getItem(TOKENKEY); }

window.onload = function()
{
    //Setup the internal state immediately so it can be used for searches/display/etc
    var p = new URLSearchParams(location.search);
    SetState_Number('ipp', p);
    SetState_Number('isize', p);
    SetState_Number('id', p);
    SetState_Bool('own', p);
    SetState_Bool('oldest', p);

    //Then, set the nav and form values from the state (but only AFTER images are loaded, we won't know what the 'next' images will be otherwise)
    reset.onclick = () =>
    {
        stateform_id.value = 0;
        stateform.submit();
    };

    stateform_search.appendChild(CreateKeywordSearch(stateform_keywords));

    // You should try to create only one API object for your entire application (or at least, one per session)
    api = new Api(null, GetToken); //Just a global api object, whatever. Null means use the default endpoint (local to self)
    // Set the default error handler for all REGULAR requests (not websocket) to show an alert to the user.
    api.default_handler.error = e =>
    {
        alert(`Error ${e.status_code}: ${e.message}`);
        console.log("Error: ", e);
    };

    api.UserSelf(new ApiHandler(
        d => { userSelf = d.result; }, 
        err => { console.warn("Not logged in?"); userSelf = {id:0}; }));

    TestGenerateKeywordSearch();
    ReloadImages();
};

function ToggleAttribute(element, attribute, value)
{
    if(element.hasAttribute(attribute)) { element.removeAttribute(attribute); return false; }
    else { element.setAttribute(attribute, value || ""); return true; }
}

function SetKeywordCache(apiData) 
{ 
    //You technically DON'T need this because of the implementation but... oh well
    keywordCache = apiData.result.objects.keyword_aggregate; 
    keywordCache.sort((a, b) => b.count - a.count);
    keywordlist.innerHTML = "";
    keywordCache.forEach(x =>
    {
        var option = document.createElement("option");
        option.value = x.value;
        //option.textContent = `${x.value} (${x.count})`;
        keywordlist.appendChild(option);
    });
}
function GetKeywordFullSearch(values) 
{ 
    values.empty = [""];
    return new RequestSearchParameter("keyword_aggregate", "*", "value NOT IN @empty", "count_desc"); 
}
function RefreshKeywordCache() 
{ 
    var values = {};
    var search = new RequestParameter(values, [ GetKeywordFullSearch(values) ]);
    api.Search(search, new ApiHandler(dd => SetKeywordCache(dd)));
}

const KEYWORDSTATE1 = [" ", "(", ")", '"'];

const TOKENSTRINGS = {
    LPAREN : "\\(",
    RPAREN : "\\)",
    AND : "AND",
    OR : "OR",
    IDENTIFIER : "([^\\s()]+)|(\"[^\"\\s]+\")"
}

function GenerateQueryFromKeywords(keywordSearch, values)
{
    var result = "";
    var tokens = {};

    Object.keys(TOKENSTRINGS).forEach(k =>
    {
        tokens[k] = new RegExp("^" + TOKENSTRINGS[k], "i");
    });

    while(keywordSearch.length)
    {
        if(keywordSearch.startsWith("(") || keywordSearch.startsWith
    }
    var result = "";
    var stack = "";

    for(var i = 0; i <= keywordSearch.length; i++)
    {
        var c = keywordSearch[i];

        if(c)
            stack += keywordSearch[i];

        if(stack.endsWith("(") || stack.endsWith(")") || stack.toUpperCase() ==)
        {
            result += stack;
            stack = "";
        }
    }

    if(stack.length)
        console.error("PARSE ERROR, YOUR QUERY PROBABLY WON'T WORK!");
    //var result = "";
    //var nextId = "";
    //var pc = ""; var lc = "";
    //var lastWasId = false;
    //var state = 0; //0 = consume whitespace, emit parens etc, 1 = consume identifier, emit special based on completion
    //var nextValId = 1;
    //var key = "";

    for(var i = 0; i < keywordSearch.length; i++)
    {
        //peek next character
        pc = keywordSearch[i];
        //Only change states if we're not at the end
        if(pc)
        {
            if(state === 0)
            {
                //If peeking next character is not state1 char, go to state 2
                if(KEYWORDSTATE1.indexOf(pc) < 0) { state = 1; }
            }
            else if(state === 1)
            {
                //|| (i === keywordSearch.length - 1)) //End of id, check crap
                if(KEYWORDSTATE1.indexOf(pc) >= 0) { state = 0; } 
            }
        }

        //Now do stuff with lc
        if(lc === "(" || lc === ")") { result += lc; } //emit as is, regardless of state
        if(state === 1)
            {
                if(nextId.toUpperCase() === "AND" || nextId.toUpperCase() === "OR") //a keyword, just emit it normally
                {
                    result += " " + nextId + " ";
                    lastWasId = false;
                }
                else //an identifier, output certain things based on current state
                {
                    if(lastWasId) result += " AND "; //implicit and
                    key = `value_${nextValId++}`; //key in the value array for our identifier
                    result += "(value ";
                    if(nextId.startsWith("-")) { values[key] = nextId.substring(1); result += "!"; }
                    else { values[key] = nextId; }
                    result += `= @${key})`;
                    lastWasId = true;
                }
                nextId = "";
                state = 0;
            }
            else { nextId += c; } //keep track of identifier
        }
        lc = c;
    }

    //No error checking, just dump it and let the API deal with it

    return result;
}

function TestGenerateKeywordSearch()
{
    var v = (n) => `(value = @value_${n})`;
    var vn = (n) => `(value != @value_${n})`;
    var tests = {
        "a AND b" : { r: `${v(1)} AND ${v(2)}`, v: ["a", "b"] }
    };
    Object.keys(tests).forEach(k =>
    {
        var values = {};
        var result = GenerateQueryFromKeywords(k, values);
        if(result !== tests[k].r) console.error(`UNITTEST FAIL ON '${k}': expect '${tests[k].r}', got '${result}'`);
        for(var i = 1; i <= tests[k].v.length; i++) 
            if(values[`value_${i}`] !== tests[k].v[i])
                console.error(`UNITTEST FAIL ON '${k}': value ${i} is not ${tests[k].v[i]}`);
    });
}

// reset the image list based on the current SearchState configuration
function ReloadImages()
{
    var values = { type : 3 };
    var request = new RequestSearchParameter("content", "*", "contentType = @type", "id_desc", SearchState.ipp)

    if(SearchState.oldest)
        request.order = "id";

    if(SearchState.id)
    {
        values["maxid"] = SearchState.id;
        if(SearchState.oldest) request.query += " and id >= @maxid";
        else request.query += " and id <= @maxid";
    }
    if(SearchState.own)
    {
        values["me"] = api.GetUidFromToken(GetToken());
        request.query += " and createUserId = @me";
    }

    var userRequest = new RequestSearchParameter("user", "id,username", "id in @content.createUserId");
    var search = new RequestParameter(values, [ request, userRequest, GetKeywordFullSearch(values) ]);

    console.debug("Image search:", search);

    imagelist.innerHTML = "";
    older.setAttribute("hidden", "");
    api.Search(search, new ApiHandler(dd =>
    {
        SetKeywordCache(dd);
        api.AutoLinkUsers(dd.result.objects.content, dd.result.objects.user);
        //Now that we know the max id, do some stuff
        older.onclick = () =>
        {
            var ids = dd.result.objects.content.map(x => x.id);
            if(SearchState.oldest) stateform_id.value = Math.max(...ids) + 1;
            else stateform_id.value = Math.min(...ids) - 1;
            stateform.submit();
        };
        older.removeAttribute("hidden");
        dd.result.objects.content.forEach(x => {
            imagelist.appendChild(CreateImageElement(x));
        });
    }));
}

//Both set the global state AND the data on the form
function SetState_Number(name, params)
{
    if(params.has(name))
    {
        var n = Number(params.get(name));
        if(n) SearchState[name] = n;
    }
    var input = document.getElementById(`stateform_${name}`);
    if(input) input.value = SearchState[name];
    else console.warn(`Somehow couldn't find form input for state '${name}'`);
}

function SetState_Bool(name, params)
{
    if(params.has(name))
        SearchState[name] = params.get(name) ? true : false;
    var input = document.getElementById(`stateform_${name}`);
    if(input) 
        input.checked = SearchState[name];
    else 
        console.warn(`Somehow couldn't find form input for state '${name}'`);
}

function CreateInput(name, value)
{
    var fragment = document.createDocumentFragment();
    var title = document.createElement("div");
    title.className = "title";
    title.textContent = `${name}:`;
    var input = document.createElement("input");
    input.setAttribute("type", "text");
    input.setAttribute("data-original", value);
    input.setAttribute("name", name);
    input.value = value;
    input.refreshModified = () =>
    {
        if(input.value !== input.getAttribute("data-original"))
            input.setAttribute(ATTR_MODIFIED, "");
        else
            input.removeAttribute(ATTR_MODIFIED);
    };
    input.oninput = input.refreshModified;
    fragment.appendChild(title);
    fragment.appendChild(input);
    return fragment;
}

function SubmitKeywordSearch(input, linkedInput)
{
    if (!input.value) {
        console.warn("Empty search");
        return;
    }
    linkedInput.value += (linkedInput.value ? " " : "") + input.value;
    if (linkedInput.refreshModified) linkedInput.refreshModified();
    input.value = "";
}
function CreateKeywordSearch(linkedInput)
{
    var input = document.createElement("input");
    input.setAttribute("placeholder", "Search");
    input.setAttribute('list', "keywordlist");
    input.setAttribute("type", "text");
    input.oninput = (e) =>
    {
        //console.log(e);
        if(e.inputType === "insertReplacementText" || (!e.inputType && e instanceof Event))
            SubmitKeywordSearch(input, linkedInput);
    };
    input.onkeydown = (e) =>
    {
        if(e.key === ENTERCODE)
            SubmitKeywordSearch(input, linkedInput);
    };
    input.onkeyup = (e) => { if(e.key === ENTERCODE) e.preventDefault() };
    input.onkeypress= (e) => { if(e.key === ENTERCODE) e.preventDefault() };
    return input;
}

function CreateInfoKeyValue(key, value, raw)
{
    var fragment = document.createDocumentFragment();
    var name = document.createElement("td");
    name.className = "key";
    name.textContent = `${key}:`;
    var data = document .createElement("td");
    data.className = "value";
    if(raw) data.innerHTML = value;
    else data.textContent = value;
    fragment.appendChild(name);
    fragment.appendChild(data);
    return fragment;
}

function CreateInfoTable(content)
{
    var table = document.createElement("table");
    table.className = "info";

    var meta = JSON.parse(content.meta || "{}");
    var row = document.createElement("tr");
    row.appendChild(CreateInfoKeyValue('rev', content.lastRevisionId));
    row.appendChild(CreateInfoKeyValue('size', meta.size || "?"));
    row.appendChild(CreateInfoKeyValue('date', (new Date(content.createDate)).toLocaleDateString()));
    table.appendChild(row);

    var spoilerCell = document.createElement("td");
    var spoiler = document.createElement("a");
    spoiler.textContent = "▼";
    spoiler.className = "spoilertoggle";
    spoiler.href = "#";
    spoiler.onclick = (e) =>
    {
        if(ToggleAttribute(spoiler, "data-shown"))
            spoiler.textContent = "▲";
        else
            spoiler.textContent = "▼";

        e.preventDefault();
        var toggles = table.querySelectorAll("[data-toggle]");
        [...toggles].forEach(x => ToggleAttribute(x, "hidden"));
    };
    spoilerCell.appendChild(spoiler);
    row.appendChild(spoilerCell);

    row = document.createElement("tr");
    row.appendChild(CreateInfoKeyValue('id', content.id));
    row.appendChild(CreateInfoKeyValue('hash', content.hash));
    row.appendChild(CreateInfoKeyValue('user', (content.createUser || {username:`#${content.createUserId}`}).username));
    row.setAttribute("hidden", "");
    row.setAttribute("data-toggle", "");
    table.appendChild(row);

    row = document.createElement("tr");
    row.appendChild(CreateInfoKeyValue('quant', meta.quantize || "-"));
    row.appendChild(CreateInfoKeyValue('link', `<a href="index.html?t=page&pid=${content.id}" target="_blank">qcs</a>`, true));
    row.appendChild(CreateInfoKeyValue('mime', content.literalType));
    row.setAttribute("hidden", "");
    row.setAttribute("data-toggle", "");
    table.appendChild(row);

    return table;
}

function CreateImageElement(content)
{
    var el = document.createElement("div");
    el.className = "image";
    var img = document.createElement("img");
    img.src = api.ResolveRelativeUrl(api.GetFileUrl(content.hash, new FileModifyParameter(SearchState.isize)));
    var link = document.createElement("a");
    link.href = api.ResolveRelativeUrl(api.GetFileUrl(content.hash));
    link.append(img);
    link.target="_blank";
    link.className = "imagelink";
    var dat = document.createElement("form");
    dat.className = "data";
    var submit = document.createElement("input");
    submit.setAttribute("type", "submit");
    submit.value = "Update";
    dat.onsubmit = (e) =>
    {
        submit.disabled = true;

        e.preventDefault();
        //We have the original content; just keep abusing the value
        var name = dat.querySelector(`[name="name"]`);
        var keywords = dat.querySelector(`[name="keywords"]`);
        content.name = name.value;
        content.keywords = keywords.value.split(' ').filter(x => x);

        api.WriteType(APICONST.WRITETYPES.CONTENT, content, new ApiHandler(d => {
            var newImage = CreateImageElement(d.result);
            el.replaceWith(newImage);
            RefreshKeywordCache(); //This is to get updated keywords in the cache
        }));
    };
    var privacy = document.createElement("div");
    privacy.className = "privacy";
    //dat.setAttribute("data-raw", JSON.stringify(content));
    dat.appendChild(CreateInput("name", content.name));
    dat.appendChild(CreateInput("keywords", content.keywords.join(" ")));
    dat.appendChild(CreateKeywordSearch(dat.querySelector(`[name="keywords"]`)));
    dat.appendChild(submit);
    el.appendChild(link);
    if (userSelf && !api.IsAllowed(content, userSelf.id, "U")) 
    {
        privacy.innerHTML += "❌";
        el.setAttribute("data-noedit", "true");
    }
    if(api.IsPrivate(content))
    {
        privacy.innerHTML += "&#128274;";
        el.setAttribute("data-private", "true");
    }
    el.appendChild(privacy);
    el.appendChild(CreateInfoTable(content));
    el.appendChild(dat);
    return el;
}

    </script>

    <style>
body {
    font-family: sans-serif;
}
#imagelist {
    padding: 1em;
    background-color: #f5fcff;
    border-radius: 1em;
    margin: 1em 0;
}
#stateform {
    border-radius: 0.5em;
    padding: 0.5em;
    background-color: #d7edff; /*#75c1ff;*/
}
#stateform > * {
    margin-bottom: 0.3em;
}
.image {
    display: inline-block;
    background-color: #d7edff;/*#75c1ff;*/
    margin: 0.5em;
    padding: 0.5em;
    border-radius: 0.5em;
    min-width: 15em;
}
.image img {
    border: 0.2em solid #0d91fc;
    border-radius: 0.2em;
    display: block;
    margin: auto;
    /*margin-bottom: 0.4em;*/
}
.privacy {
    float: right;
}
.spoilertoggle {
    text-decoration: none;
}
.info {
    margin: auto;
    /*float: right;*/
}
.info .key {
    text-align: right;
    font-size: 0.6em;
    color: cornflowerblue;
}
.info .value {
    font-weight: bold;
    font-size: 0.6em;
    color: blue;
}
.info .spoilertoggle {
    font-size: 0.6em;
    cursor: pointer;
    color: cornflowerblue;
    line-height: 0.6em;
    vertical-align: middle;
}
.data .title {
    /*font-weight: bold;*/
    font-size: 0.8em;
    color: cornflowerblue;
}
.data input {
    width: 100%;
    box-sizing: border-box;
    margin-bottom: 0.2em;
    border-radius: 2px;
    border: 1px solid cornflowerblue;
}
.data input[type='submit'] {
    background-color: cornflowerblue;
    color: white;
    border: 1px solid blue;
    border-radius: 2px;
    cursor: pointer;
}
input[data-modified] {
    border: 1px solid red;
    background-color: #fff1ed;
}
input:disabled {
    opacity: 0.5;
}
.image[data-private] img {
    border-color: red;
}
.image[data-noedit] {
    background-color: #EEE;
}
.image[data-noedit] .data input[type='submit'] {
    background-color: #999;
    border-color: #666;
}
    </style>

</head>

<body>
    <div id="main">
        <form id="stateform" method="GET">
            <div id="stateform_text">
                <label for="stateform_ipp">Images per page:</label>
                <input name="ipp" id="stateform_ipp">
                <label for="stateform_isize">Images size:</label>
                <input name="isize" id="stateform_isize">
            </div>
            <div id="stateform_search">
                <label for="stateform_keywords">Keywords:</label>
                <input name="keywords" id="stateform_keywords" placeholder="a AND (b OR c)">
            </div>
            <div id="stateform_checkboxes">
                <label for="stateform_own">Only mine:</label>
                <input name="own" type="checkbox" id="stateform_own">
                <label for="stateform_oldest">Oldest first:</label>
                <input name="oldest" type="checkbox" id="stateform_oldest">
            </div>
            <input name="id" id="stateform_id" type="hidden" value="0">
            <input type="submit" value="Update">
            <button type="button" id="reset">Reset (beginning)</button>
            <button type="button" id="older" hidden="">Next set</button>
        </form>
        <div id="imagelist">

        </div>
        <datalist id="keywordlist"></datalist>
    </div>
</body>

</html>