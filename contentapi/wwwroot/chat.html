<!DOCTYPE html>
<html lang="en">

<head>

    <title>SBS Chat</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <script src="api.js"></script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <meta name="rating" content="general">
    <meta name="description" content="SBS default implementation chat">

    <script>
//NOTE: this file has nothing to do with index.html or any script/etc other than api.js
//Use it as a starting point for a chat if you want.
var api;
var ws;
var pid;

//duplicate from index.js
const TOKENKEY = "contentapi_defimpl_userkey";
function GetToken() { return localStorage.getItem(TOKENKEY); }

window.onload = function()
{
    //NOTE: there is no error checking in this frontend, because it is not meant to be used full time. Furthermore,
    //I think it would distract from the ideas I'm trying to convey, which is just how the API is used to make
    //a functioning website.

    var parameters = new URLSearchParams(location.search);
    var state = Object.fromEntries(parameters);

    if(!parameters.has("pid")) //state
    {
        alert("No page id set! This chat only works with one room at a time");
        return;
    }

    pid = Number(parameters.get("pid"));

    api = new Api(null, GetToken); //Just a global api object, whatever. Null means use the default endpoint (local to self)
    api.default_handler.error = e =>
    {
        alert(`Error ${e.status_code}: ${e.message}`);
        console.log("Error: ", e);
    };

    ws = api.AutoWebsocket(new WebsocketAutoConfig(
        live => {
            wslog("Live data: \n" + JSON.stringify(live.data, null, 2), "systemmsg");
        }, 
        userlist => {
            //Might want to do other things, so we call the function rather than pass it
            setUserlist(userlist);
            //wslog("Userlist data : \n" + JSON.stringify(userlist.data, null, 2), "userlistmsg");
        },
        //The websocket state itself, as well as reconnects, are handled automatically. However,
        //if you want to keep track of the errors going on so you can do your OWN things (not impacting
        //the auto websocket, since it's automatic), you use this event tracker. It reports when a new
        //websocket is created (check newWs for truthy value), and also when the error was severe enough
        //to not attempt a reconnect (check closed for truthy value)
        (message, response, newWs, closed) =>
        {
            console.warn("Websocket error: ", message, response);

            if(closed)
            {
                alert("Websocket error forced a close, error: " + message);
                ws = null;
            }
            else if(newWs)
            {
                console.debug("New websocket was created, tracking");
                ws = newWs;
            }
        }
    ));

    //Make the initial request of the content and the initial comments
    ws.sendRequest("request", new RequestParameter({
        "pid": pid
    }, [
        new RequestSearchParameter("content", "id, name", "id = @pid"),
        new RequestSearchParameter("message", "*", "contentId = @pid and !notdeleted()", "id", 30),
        new RequestSearchParameter("user", "*", "id in @message.createUserId")
    ]), response =>
    {
        console.log(response);
        document.getElementById("pagetitle").textContent = response.data.data.content[0].name;
    });

    //Also, say we're in the room
    var statuses = {};
    statuses[`${pid}`] = "active";
    ws.sendRequest("setuserstatus", statuses, response => console.log("Successfully set user status"));
};

function createUserlistUser(user, status)
{
    var element = document.createElement("div");
    element.textContent = user.username;
    element.className = "user";
    element.setAttribute("title", status);
    return element;
}

function setUserlist(data)
{
    console.debug("SetUserList called with response: ", data);
    var userlist = document.getElementById("userlist");

    var usersById = api.KeyById(data.data.user);

    //response should have statuses and data, always same format (assuming you get a single status)
    //furthermore, the statuses are always a dictionary because it could have multiple content in it.
    if(data.statuses[pid])
    {
        userlist.innerHTML = "";
        Object.keys(data.statuses[pid]).forEach(x => {
            userlist.appendChild(createUserlistUser(usersById[x], data.statuses[pid][x]))
        });
        //Need to get users and whatever!
    }
    else
    {
        console.debug(`No statuses found in content ${pid}, this is strange!`);
    }
}
    </script>

    <style>
:root {
    --rightpanewidth: 12rem;
    --titleheight: 2rem;
    --postareaheight: 6rem;
    --stdborder: 1px solid #777;
    --postsubmitwidth: 3rem;
}
body, div { padding: 0; margin: 0; box-sizing: border-box; overflow: hidden; }
#main {
    width: 100vw;
    height: 100vh;
    margin: 0;
    padding: 0;
    overflow: none;
    position: relative;
}
#leftpane {
    width: calc(100% - var(--rightpanewidth));
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
}
#rightpane {
    width: var(--rightpanewidth);
    height: 100%;
    background-color: #EEE;
    border-left: var(--stdborder);
    overflow-y: auto;
    position: absolute;
    top: 0;
    right: 0;
}
#titlearea {
    width: 100%;
    height: var(--titleheight);
    background-color: #AAA;
    border-bottom: var(--stdborder);
}
#postarea {
    width: 100%;
    height: var(--postareaheight);
    border-top: var(--stdborder);
    position: relative;
}
#postbox {
    height: 100%;
    width: calc(100% - var(--postsubmitwidth));
    box-sizing: border-box;
    position: absolute;
    resize: none;
    top: 0;
    left: 0;
}
#postsubmit {
    height: 100%;
    width: var(--postsubmitwidth);
    box-sizing: border-box;
    position: absolute;
    top: 0;
    right: 0;
    font-size: 1.5em;
}
#messagearea {
    width: 100%;
    overflow-y: scroll;
    height: calc(100vh - var(--postareaheight) - var(--titleheight))
}
#userlist {
    width: 100%;
    border-bottom: var(--stdborder);
}
    </style>

</head>

<body class="">
    <div id="main" class="">
        <div id="leftpane" class="">
            <div id="titlearea"><h2 id="pagetitle"></h2></div>
            <div id="messagearea"></div>
            <div id="postarea">
                <textarea id="postbox"></textarea>
                <button id="postsubmit">&#x27a4;</button>
            </div>
        </div>
        <div id="rightpane" class="">
            <div id="rightpanecontent" class="">
                <div id="userlist"></div>
                <div id="activitylist"></div>
            </div>
        </div>
    </div>
</body>

</html>